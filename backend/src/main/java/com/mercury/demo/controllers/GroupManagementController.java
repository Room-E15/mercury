package com.mercury.demo.controllers;

import com.mercury.demo.entities.AlertGroup;
import com.mercury.demo.entities.Member;
import com.mercury.demo.entities.MemberAlertResponse;
import com.mercury.demo.entities.Membership;
import com.mercury.demo.entities.idclass.MemberAlert;
import com.mercury.demo.entities.responses.GetGroupsResponse;
import com.mercury.demo.entities.responses.JoinGroupResponse;
import com.mercury.demo.repositories.AlertGroupRepository;
import com.mercury.demo.repositories.MemberAlertResponseRepository;
import com.mercury.demo.repositories.MemberRepository;
import com.mercury.demo.repositories.MembershipRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

@Controller // This means that this class is a Controller
@RequestMapping(path="/group") // This means URL's start with /group (after Application path)
public class GroupManagementController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AlertGroupRepository alertGroupRepository;
    @Autowired
    private MembershipRepository membershipRepository;
    @Autowired
    private MemberRepository memberRepository;
    @Autowired
    private MemberAlertResponseRepository alertResponseRepository;

    @PostMapping(path="/createGroup") // Map ONLY POST Requests
    public @ResponseBody String createGroup (@RequestParam String groupName,
                                             @RequestParam String memberId
    ) {
        AlertGroup group = new AlertGroup(groupName);
        final Optional<Member> user = memberRepository.findById(memberId);

        if (user.isEmpty()) {
            throw new RuntimeException(String.format("User with the id %s not found", memberId));
        }
        group = alertGroupRepository.save(group);

        Membership membership = new Membership(user.get().getId(), group.getId(), true);

        membershipRepository.save(membership);
        return "Saved";
    }

    // TODO change to GET request
    @PostMapping(path="/getGroups") // Map ONLY POST Requests
    public @ResponseBody List<GetGroupsResponse> getGroups (@RequestParam String memberId
    ) {
        // TODO: List groups by at first Leader groups then alphabetized
        final List<Membership> groupMemberships = membershipRepository.findByMemberId(memberId);
        List<GetGroupsResponse> groupResponseList = new ArrayList<>();

        for (final Membership membership : groupMemberships) {
            final AlertGroup correspondingGroup = alertGroupRepository.findById(membership.getGroupId()).orElseThrow(() -> new RuntimeException(
                    String.format("Corresponding group with groupId %s not found.", membership.getGroupId())));

            final List<Membership> allMembersInGroup = membershipRepository.findByGroupId(correspondingGroup.getId());
            final Map<Membership, Member> membersByMembership = allMembersInGroup.stream().collect(Collectors.toMap(Function.identity(),
                    newMembership -> memberRepository.findById(newMembership.getMemberId()).orElseThrow(() -> new RuntimeException(String.format("Corresponding member with memberId %s not found.", membership.getMemberId())))));

            final List<Member> membersList = membersByMembership.entrySet().stream().filter(entry -> !entry.getKey().isLeader()).map(Map.Entry::getValue).toList();
            final List<Member> leadersList = membersByMembership.entrySet().stream().filter(entry -> entry.getKey().isLeader()).map(Map.Entry::getValue).toList();


            // sanitize member and leader lists to remove ids

            // Update with proper responses
            if (membership.isLeader()) {
                // Get the statuses of all members
                List<Member> allMembers = new ArrayList<>(membersList);
                allMembers.addAll(leadersList);
                List<MemberAlert> ids = allMembers.stream().map(member -> new MemberAlert(member.getId(), ));
                // only get the newest response from each group member TODO ask if this is right design choice
                // should we wipe old responses?
                final List<MemberAlertResponse> latestResponses = alertResponseRepository.findAllById();
                groupResponseList.add(new GetGroupsResponse(correspondingGroup.getId(), correspondingGroup.getGroupName(), membersList, leadersList, responses))
            } else {
                groupResponseList.add(new GetGroupsResponse(correspondingGroup.getId(), correspondingGroup.getGroupName(), membersList, leadersList, null));
            }
        }
        return groupResponseList;
    }

    @PostMapping(path="/joinGroup") // Map ONLY POST Requests
    public @ResponseBody JoinGroupResponse joinGroup (@RequestParam String memberId,
                                                      @RequestParam String groupId
    ) {
        final Member user = memberRepository.findById(memberId).orElseThrow(() -> new RuntimeException(String.format("User with the id %s not found", memberId)));
        final AlertGroup group = alertGroupRepository.findById(groupId).orElseThrow(() -> new RuntimeException(String.format("Group with the id %s not found", groupId)));

        Membership membership = new Membership(user.getId(), group.getId(), false);
        membership = membershipRepository.save(membership);

        return new JoinGroupResponse(memberId, groupId);
    }
}